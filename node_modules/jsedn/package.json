{
  "name": "jsedn",
  "description": "js implementation of edn",
  "version": "0.3.5",
  "keywords": [
    "lisp",
    "clojure",
    "edn",
    "serialization",
    "datomic"
  ],
  "maintainers": [
    {
      "name": "Shaun Gilchrist",
      "email": "shaunxcode@gmail.com",
      "url": "http://order-of-no.posterous.com"
    }
  ],
  "contributors": [
    {
      "name": "Shaun Gilchrist",
      "email": "shaunxcode@gmail.com",
      "url": "http://order-of-no.posterous.com"
    }
  ],
  "bugs": {
    "url": "http://www.github.com/shaunxcode/jsedn/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://www.github.com/shaunxcode/jsedn"
  },
  "devDependencies": {
    "coffee-script": "latest",
    "underscore": "latest",
    "microtime": "latest"
  },
  "dependencies": {
    "commander": "latest",
    "type-component": "latest",
    "equals": "latest"
  },
  "bin": {
    "jsedn": "./bin/jsedn"
  },
  "main": "index.js",
  "readme": "jsedn\n=====\n\nA javascript implementation of [edn](https://github.com/edn-format/edn). To see it in action checkout the [edn playground](https://shaunxcode.github.com/jsedn). If you open your browser console you will have access to a global jsedn object with which you can try things beside JSON encoding. I recommend `jsedn.unify(\"[?x was always better than ?y]\", {x: \"sonic\", y: \"mario\"}).jsEncode()`.  \n\n## Getting Started\n\n### Install\n\tnpm install jsedn\n\n### Use in a web page directly \n\tuse jsedn.js which is a standalone version that will provide a global \"jsedn\".  \n\n### Code\n\tvar edn = require(\"jsedn\");\n\tvar map = edn.parse(\"{:a 5 [1 2] {:name :mike :age 40}}\");\n\tconsole.log(map.at(new edn.Vector([1, 2])).at(edn.kw \":name\"));\n\nWill output ```\"mike\"```.\n\nNow the other way:\n\n\tedn.encode({a: 1, \"id\": 333});\n\nWill output ```{\"a\" 1 \"id\" 333}```. Finally lets encode js into edn then back to js:\n\n\tedn.parse(edn.encode({\n\t\ta: 1, \n\t\tb: {\n\t\t\tage: 30, \n\t\t\tfeeling: [\"electric\", \"pink\"]\n\t\t}\n\t})).at(\"b\").at(\"feeling\").at(0)\nWill output ```\"electric\"```. Definitely working in both directions. \n\n###Command Line\nIf you have installed via npm you will have a jsedn script that accepts input via pipe/stdin. Currently takes -s flag for \"select\" which you pass a path separated by space. -j encodes input as JSON. -p indicates pretty print for json output.\n\n\t> echo \"{:a first-item :b [{:name :walter :age 50 :kids [:A :B :C]}]}\" | jsedn -s \":b 0 :kids 2\"\n\toutputs: :b 0 :kids 2 => :C\n\t\n### Testing\nI have developed this in a very test driven manner e.g. each test written  before the next feature is implemented. Baring that in mind it means any bugs you find it would be awesome if you could edit the tests adding one which clearly indicates the bug/feature request.\n\n\tcoffee tests/primitives.coffee\n\t\n## API\n#####parse (ednString)\nWill turn a valid edn string into a js object structure based upon the classes details below.\n\n\tedn.parse(\"{:a-keyword! [1 2 -3.4]}\");\n\n\n#####encode (jsObj)\nWill encode both native JS and any object providing a ednEncode method.\n\n\tedn.encode({\"a-keyword!\": [1,2,-3.4]});\n\n\n#####setTagAction (tag, action)\nWill add the tag action to be performed on any data prepended by said tag.\n\n\tedn.setTagAction(new edn.Tag('myApp', 'tagName'), function(obj) {\n\t\t//do stuff with obj here and then return it\n\t\tvar mutatedObj = thingsHandlerDoes(obj);\n\t\treturn mutatedObj;\n\t});\n\n#####setTokenPattern (tokenName, pattern) \nIf for some reason you would like to over-ride or add a new token pattern. \n\n\tedn.setTokenPattern()))\n\n#####setTokenAction (tokenName, actionCallback)\nAllows for customization of token handling upon match. For instance if you decided you would prefer nil to be represented by undefined instead of null (default).\n\n\tedn.setTokenAction('nil', function(token) { return undefined;});\n\n#####setTypeClass (type, class)\nThis is useful if you want to over-ride the naive implementations of Map etc. \n\n\tedn.setTypeClass('List', MyListClass));\n\n##### atPath (obj, path)\nSimple way to lookup a value in elements returned from parse. \n\n\tvar parsed = edn.parse(\"[[{:name :frank :kids [{:eye-color :red} {:eye-color :blue}]}]]\");\n\tedn.atPath(parsed, \"0 0 :kids 1 :eye-color\");\n\t\npath is a space separated string which consists of index (remember Array/Set/Vector are all 0 indexed) and key locations. \n\n##### encodeJson\nProvides a json encoding including type information e.g. Vector, List, Set etc. \n\n\tconsole.log(edn.encodeJson(edn.parse(\"[1 2 3 {:x 5 :y 6}]\")));\n\t#yields\n\t{\"Vector\":[1,2,3,{\"Map\":[{\"Keyword\": \":x\"},5,{\"Keyword\":\":y\"},6]}]}\n\t\n##### toJS \nAttempts to return a \"plain\" js object. Bare in mind this will yield poor results if you have any **Map** objects which utilize composite objects as keys. If an object has a **hashId** method it will use that when building the js dict. \n\n\tvar jsobj = edn.toJS(edn.parse(\"[1 2 {:name {:first :ray :last :cappo}}]\"));\n\t#yields\n\t[1, 2, {\":name\": {\":first\": \":ray\", \":last\": \":cappo\"}}]\n\nNotice that you can not always go back the other direction. In the example above if you were to edn.parse it you would end up with:\n\n\t[1 2 {\":name\" {\":first\" \":ray\" \":last\" \":cappo\"}}]\n\nIn which you have strings for keys instead of keywords. At one point I would \"infer\" that if a string started with a \":\" it would be treated as a keyword. This caused more problems than it resolved which brings us to our next methods. \n\n\n##### kw (string)\nInterns a valid keyword into an edn.Keyword object e.g. ```edn.kw(\":myns/kw\")``` \n\n##### sym (string)\nInterns a valid symbol into an edn.Symbol object e.g. ```edn.sym(\"?name\")```\n\n##### unify (data, values, [tokenStart])\nUnifies the first form with the second. Useful for populating a \"data template\". It accepts either edn objects or strings as arguments. \n\n\tedn.unify(\"{?key1 ?key1-val ?key2 ?key2-val :all [?key1-val ?key2-val]}\", \"{key1 :x key1-val 200 key2 :y key2-val 300}\");\n\t#yields\n\t{:x 200 :y 300 :all [200 300]}\n\t\nA third argument is expected which can be used to indicate the \"tokenStart\" first character for unify tokens. This defaults to \"?\". \n\nAn example with Map as data and js obj as values and changing the tokenStart to $\n\n\tedn.unify(new edn.Map([edn.kw(\":place\"), edn.sym(\"$place\")]), {place: \"salt lake city\"}, \"$\");\n\t#yields \n\t{:place \"salt lake city\"}\n\n## Classes/Interfaces\n\n#### Symbol\nUsed to create symbols from with in js for encoding into edn. \n\n### Keyword\nAs above but for keywords. Note that the constructor enforced that keywords start with a \":\" character. \n\n####Iterable [List Vector Set]\nList, Vector and Set all implement the following methods:\n\n\texists (key) -> boolean indicating existance of key\n\tat (key) -> value at key in collection\n\tset (key, val) -> sets key/index to given value\n\teach (iter) -> iterate overa all members calling iter on each, returns results\n\tmap (iter) -> iterate over all members calling iter on each and returning a new instace of self\n\twalk (iter) -> recursively walk the data returning a new instance of self \n\t\n####Map\nSupports any type of object as key. Supports all of the methods listed for Iterable plus ```indexOf``` which returns the index of the item, which can be 0 and thus non-truthy. \n\n```each```, ```map``` and ```walk``` all accept a callback which takes the value as the first argument and the key as the second. In the case of map and walk if you want to modify the key you must return a ```Pair``` object e.g. \n\n\tedn.parse(\"{:x 300 y: 800}\").map(function(val, key){\n\t\treturn new edn.Pair(edn.kw(\"#{key}-squared\"), val * val);\n\t});\n\t\n\t#yields\n\t{:x-squared 90000 :y-squared 640000}\n\t\n####Tag\nUsed for defining Tag Actions. Has a constructor which accepts 2..n args where the first arg is your a namespace and the rest are used to categorize the tag. **Tag** provides two methods ```ns``` and ````dn```:\n\n\tvar tag = new edn.Tag('myApp', 'people', 'special', 'stuff');\n\tconsole.log(tag.ns()); => myApp\n\tconsole.log(tag.dn()); => myApp/people/special/stuff\n\nConstructor also supports being passed single argument delimited by / e.g. ```new edn.Tag('myApp/people/special/stuff')```. \n\n####Tagged\nIf you do not have tag handlers specified for a given tag you will end up with **Tagged** items in your result which have two methods: \n\n\ttag() -> Tag object found\n\tobj() -> Object to be tagged\n\n**Tagged** pairs can also be used when you want to serialize a js obj into edn w/ said tagging e.g. \n\t\n\tedn.encode(new edn.Tagged(new edn.Tag(\"myApp\", \"Person\"), {name: \"walter\", age: 300}));\n\noutputs: \n\t\n\t#myApp/person {\"name\" \"walter\" \"age\" 300}\n\n##Conversion Table\n\n| element         | edn                  | jsedn              | js |\n| --------------- | -------------------- | ------------------ | --- |\n| nil             | ```nil```            | ```null```         | ```null``` | \n| boolean         | ```true false```     | ```true false```   | ```true false``` | \n| character       | ```\\c```             | ```\"c\"```          | ```\"c\"``` | \n| string          | ```\"some string\"```  | ```\"some string\"``` | ```\"some string\"``` |\n| symbol          | ```?sym~b~o!ol```    | ```edn.sym \"?sym~b~o!ol\"``` | ```\"?sym~b~o!ol\"``` | \n| keywords        | ```:keyword```       | ```edn.kw \":keyword\"```| ```\":keyword\"``` |  \n| integer         | ```666```            | ```666```          | ```666``` | \n| floating point  | ```-6.66```          | ```-6.66```        | ```-6.66``` | \n| list            | ```(a b (c d))```    | ```new edn.List([(edn.sym \"a\"), (edn.sym \"b\"), new edn.List([(edn.sym \"c\"), (edn.sym \"d\")])])``` | ```[\"a\", \"b\", [\"c\", \"d\"]]``` | \n| vector          | ```[a b c]```        | ```new edn.Vector([(edn.sym \"a\"), (edn.sym \"b\"), (edn.sym \"c\")])``` | ```[\"a\", \"b\", \"c\"]``` |\n| map             | ```{:a 1 :b 2}```    | ```new edn.Map([(edn.kw \":a\"), 1, (edn.kw \":b\"), 2])``` | ```{a: 1, b: 2}``` |\n| set             | ```#{1 2 3}```       | ```new edn.Set([1, 2, 3])``` | ```[1 2 3]``` | \n| tagged elements | ```#tagName [1 2]``` | ```new edn.Tagged(new edn.Tag(\"tagName\"), new end.Vector([1, 2]))``` | n/a |\n\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "jsedn@0.3.5",
  "_from": "jsedn@"
}
